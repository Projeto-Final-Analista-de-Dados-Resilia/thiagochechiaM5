# -*- coding: utf-8 -*-
"""polkadotSolana.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14rJDfeyGRTPjNlah9_2RNOSbtUqDEXJH
"""

import pandas as pd
import matplotlib.pyplot as plt

import warnings
warnings.filterwarnings('ignore')

url = 'https://drive.google.com/uc?export=download&id=1zTrc5x1t38CYcz863A906XGx1faEzrUE'
polkadot = pd.read_csv(url)
polkadot

"""- Encontrando o numero de linhas e colunas do Dataframe"""

# Suponha que 'polkadot' seja o seu DataFrame
shape = polkadot.shape

# Agora, você pode imprimir ou usar a tupla 'shape' para obter o número de linhas e colunas
print("Número de Linhas:", shape[0])
print("Número de Colunas:", shape[1])

"""- Encontrando o resumo estatistico com o DESCRIBE"""

# Suponha que 'polkadot' seja o seu DataFrame
resumo_estatistico = polkadot.describe()

# O resultado 'resumo_estatistico' conterá as estatísticas descritivas das colunas numéricas
print(resumo_estatistico)

"""- O codigo abaixo verifica se ha valores nulos no dataframe"""

valores_nulos = polkadot.isnull().sum()
missing_values = polkadot.isna().sum()

"""- Para verificar valores faltantes em uma coluna especifica"""

valores_faltantes_na_coluna = polkadot['Marketcap'].isnull().sum()
valores_faltantes_na_coluna3 = polkadot['Marketcap'].isna().sum()

#'https://drive.google.com/uc?export=download&id=1wji-DooPqQ3RzCotMFoszmjzFSakf0zH'# comando para chamar direto do google drive

"""- Transformando a coluna data no formato Datatime"""

polkadot['Date'] = pd.to_datetime(polkadot['Date'])

url = 'https://drive.google.com/uc?export=download&id=1QJG6AzqG4BO5g_DvpXXIR8d9z0If92sG'
solana = pd.read_csv(url)
solana

"""- Obtendo numero de linhas e colunas , metodo shape tuplado*"""

# Suponha que 'polkadot' seja o seu DataFrame
shape2 = solana.shape

# Agora, você pode imprimir ou usar a tupla 'shape' para obter o número de linhas e colunas
print("Número de Linhas:", shape2[0])
print("Número de Colunas:", shape2[1])

"""- Encontrando o resumo estatistico da Tabela com o metodo DESCRIBE"""

# Suponha que 'solana' seja o seu DataFrame
resumo_estatistico2 = solana.describe()

# O resultado 'resumo_estatistico' conterá as estatísticas descritivas das colunas numéricas
print(resumo_estatistico2)

valores_nulos2 = solana.isnull().sum()
missing_values2 = solana.isna().sum()

valores_faltantes_na_coluna2 = solana['Date'].isnull().sum()
valores_faltantes_na_coluna4 = solana['Date'].isna().sum()

"""- Criando os Histogramas de todas as colunas da cripto Polkadot"""

for coluna in polkadot.columns:
    plt.figure(figsize=(8, 4))  # Define o tamanho da figura
    plt.hist(polkadot[coluna], bins=20, color='skyblue', edgecolor='black')  # Cria o histograma
    plt.xlabel(coluna)  # Define o rótulo do eixo x
    plt.ylabel('Frequência')  # Define o rótulo do eixo y
    plt.title(f'Histograma de {coluna}')  # Define o título do histograma
    plt.show()  # Exibe o histograma

"""- ENCONTRANDO OUTLIERS pelo MéTODO Estatístico IQR (Interquartile Range - Intervalo Interquartil)



"""

# Filtrar apenas as colunas numéricas
colunas_numericas = polkadot.select_dtypes(include=['number'])

# Definir a função para encontrar outliers usando o método IQR
def find_outliers_iqr(data):
    Q1 = data.quantile(0.25)
    Q3 = data.quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    outliers = (data < lower_bound) | (data > upper_bound)
    return outliers

# Encontrar outliers em todas as colunas numéricas
outliers = colunas_numericas.apply(find_outliers_iqr)

# Mostrar os valores de outliers
print("Outliers em cada coluna numérica:")
print(outliers)

"""- Criando os Histogramas da Criptomoeda Solana"""

for coluna in solana.columns:
    plt.figure(figsize=(8, 4))  # Define o tamanho da figura
    plt.hist(solana[coluna], bins=20, color='skyblue', edgecolor='black')  # Cria o histograma
    plt.xlabel(coluna)  # Define o rótulo do eixo x
    plt.ylabel('Frequência')  # Define o rótulo do eixo y
    plt.title(f'Histograma de {coluna}')  # Define o título do histograma
    plt.show()  # Exibe o histograma

# Filtrar apenas as colunas numéricas
colunas_numericas2 = solana.select_dtypes(include=['number'])

# Definir a função para encontrar outliers usando o método IQR
def find_outliers_iqr2(data):
    Q1 = data.quantile(0.25)
    Q3 = data.quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    outliers = (data < lower_bound) | (data > upper_bound)
    return outliers

# Encontrar outliers em todas as colunas numéricas
outliers2 = colunas_numericas2.apply(find_outliers_iqr2)

# Mostrar os valores de outliers
print("Outliers em cada coluna numérica:")
print(outliers2)

import pandas as pd

# Suponha que 'polkadot' seja o seu DataFrame contendo a coluna "marketcap"
# Formate a coluna "marketcap" em formato monetário
polkadot['marketcap'] = polkadot['Marketcap'].apply(lambda x: '${:,.2f}'.format(x))

# O código acima vai formatar os valores em "marketcap" com o símbolo de dólar, vírgulas como separador de milhares e duas casas decimais.

"""Os primeiros registros estavam zerados o que significa que ela na havia sido capitalizada no mercado."""

polkadot['Marketcap'].tail()

polkadot['Marketcap'].head()

"""A formatação de uma coluna, como "marketcap" (capitalização de mercado), em um DataFrame do Pandas refere-se a como você deseja que os valores sejam exibidos ao imprimir ou visualizar o DataFrame. Se você deseja formatar a coluna "marketcap" para exibir os valores em um formato específico, como valores monetários com vírgulas e símbolo de moeda, você pode usar a função applymap para aplicar um formato a todos os valores dessa coluna.

Após aplicar essa formatação, os valores da coluna "marketcap" serão exibidos como strings no formato de moeda, por exemplo, "$1,234,567,890.12".

Lembre-se de que, ao formatar a coluna dessa maneira, você está convertendo os valores originais em strings. Portanto, se precisar realizar cálculos adicionais com esses valores, você deve convertê-los de volta para o formato numérico quando necessário.
"""